/*
NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
mMMMMMMMMMNNNmmNNNMMNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
mmNMMNMMMMNNNNNmmmddhdddNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
mddNMMNy:/odNmmddmmNNmdhhddmNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NmmdNMNd:--+dNmmddhhddmmhsyhhmdmmNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NmNmdNmy:.-oyNmmmhmdhho+sososyhhhddNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NmmNdh+-`.:oyNNdmmdmmdo-://oysssyhhhdmNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
Nmmmoyyyo+osdNmdmmddNNhs+/::/+osyssydyhdNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NNmhsymMMNmmmmdmdNNddNmsso+++////ossssyyhdmNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
mhhhmNNMNNNhssshhmmddmmssyooooso/::+oysshhhhmMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
mmdhdddNNdyoosyhdmddmmmsoooooyysyys/::/oyyhhhyMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
mdddhddmhsooshdmdmdhhyyyysso/ooo+syhhs/-/+shyhMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
dyyhdmd+ososhdmdmyyhhhhhhhyo++o/+///+ohhso++sdMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
dhdmNNdsossyhmdmsydhssssyhhs/++o/o+//:++yhhy+/hNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
mdmNNNNmhysshddyshdyyy/oss+s::/:://++///++++/::hmNNNNNNNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NNMNNNmmNNdymNNhshdshdyhdysh+sy+-:++osssosss++yNNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NmNNNmdNNmNmmmNmyyddyyhdhydyohys/-oo+osssysyyohNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
mmNNNhdNmmNNmNMMNhyyhhhdhyyhmmyh+-/s+sysssyyhyydNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
mNMMMhdNdmMNMMMMMNNmdhdddmhdmmNho/-osoyyo++oyddhhNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NMMMNmhNdNMNMNMMNmNNNmmmdyoohmhoyo::hsooo++oooydhymMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMNNNhmNNMmmNMNNmmmmdmmdyhhoyddddoo++yoyysooossyhsmMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMNNNmmNNNmdNdNmmddhhhdNNhsmNssdooo/dso++osyyysoymMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMNNNNmNNNNNmddmmNhshNmmmNmNMdhNsh/ohho++/:++MMNNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MNNNMMNNNNmmmhhhhdyosdNmdmMMhoNmhdmys+ooo++/+MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
mmNNNMMNNNNmddmdoodmMMNmmNNhssdmNMMMNdNd/osomMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NmNdhMNmNNMNmdNddohmMMNNNmdmdddNMMMMMMMMmMNNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NmNhmMmmmmNNmdNyoNMNmNmdhyyyhdhoyNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NmdmMmmddddNmmdys+hmMMMmmhysssyy++dMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NmdNMMdmdddmmNNyshmNNNNNNNdhhs+yy//dMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NmNMMMdmdddmmMNysdmNNMMMNhhNdhs+y+/:mMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
mmNMMNhmmddNNNMdyydmMMMNdyshNhyoss+:/MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NmNMMddmmmmNMNMNdsymNNmdhhdNMNdhsss+:yMMMMMMMMMMMMMMMMNNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMdhmmmmmNMNNMmshNMMMmmMMMMMmNdyo+//NMMMMMMMMMMMMMMMhNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMmhmmmmmmNMMNNMyshdhhhyhNMMMMMMdhso+sMMMMMMMMMMMMMMMhmMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMmdmmmmmmmNMMMmNm+ys++oyyNMMMMMMNmmyyoyNMMMMMMMMMMMMMddMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NmmmmmmmmmmmNMNNmNNyyo+/oohNMMMMMMMMdhhsshmMMMMMMMMMMMyNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
mmNNNNNNmmmmNMMNmmddNmmdhhdmMMMMMMMMMNddhssshmmNNNmmdhdMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NNNNNNNNNNNNNNNNmNNNNMMMMMNomMMMMMMMMMNNmdhhyyyyyyyhdmMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
Nd+oNMMMMMMMmodo++++++++++m..yNMMMMMNo+mNMMmhssshdNMMNhNMMMMMMMMMMMddMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MN+ /NMMMMMm: d` -ssssss+`d. `+mMMMMN. dNm+:+syso//hNN--yNMMMMMMMd+`yMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMN+ /NMMMm: oM` +NMMMMMNdN. /`.yNMMN. dh.omMMMMMNy.oM- `:hNMMMm+.  yMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMN/ /NMm: oNy` :sssmMMMMN. dh-`/mMN. d-/NMMMMMMMMy`m- y/`/dmo..o: yMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMN/ /m: +NNy. /yyyNMMMMN. dNNo`.yN- d.oNMMMMMMMMd d- mNh-`.`+mN/ yMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMN/ . +NMMN- oNMMMMMNdN. dMMMd:`/. ds.dNMMMMMMm::M- dMMNy/dMMN/ yMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMN/ +NMMMN- /yyyyyys d. dMMMMNo`  dNy-+ymmmho-+NN- dMMMMMMMMN/ yMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMNyNMMMMN+::::::::::m+/mMMMMMMd: dMMNho///+ymMMN+/mMMMMMMMMNs/hMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMNMMMMMMMMMMMMMMMMMMMMMMMMMMMMNsmMMMMMMMMMMMMMMNNNNMMNNNMMNNNNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNMMMMMMMMMMMMMMNMMNMNMMMNMMNNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNMMNMNMMMNMMNNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNNNNMMNNNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
*/

import * as chalk from 'chalk';

import * as fs from 'fs';

import { fstat, readFileSync } from 'fs';

import { Browser, Page } from 'puppeteer';

import path = require('path');

import { deleteFiles, checkingCloses } from '../api/helpers';
import { Whatsapp } from '../api/whatsapp';
import { CreateConfig, defaultOptions } from '../config/create-config';
import { tokenSession } from '../config/tokenSession.config';
import { checkFileJson } from '../api/helpers/check-token-file';
import { SocketState, SocketStream } from '../api/model/enum';
import { SessionTokenCkeck, saveToken } from './auth';
import { initWhatsapp, initBrowser } from './browser';
import { welcomeScreen } from './welcome';
/**
 * A callback will be received, informing the status of the qrcode
 */
export type CatchQR = (
  qrCode: string,
  asciiQR: string,
  attempt: number,
  urlCode?: string
) => void;

/**
 * A callback will be received, informing the customer's status
 */
export type StatusFind = (statusGet: string, session: string) => void;

/**
 * A callback will be received, informing user about browser and page instance
 */
export type BrowserInstance = (
  browser: string | Browser,
  waPage: false | Page
) => void;

export interface CreateOptions extends CreateConfig {
  /**
   * You must pass a string type parameter, this parameter will be the name of the client's session. If the parameter is not passed, the section name will be "session".
   */
  session: string;
  /**
   * A callback will be received, informing the status of the qrcode
   */
  catchQR?: CatchQR;
  /**
   * A callback will be received, informing the customer's status
   */
  statusFind?: StatusFind;
  /**
   * Pass the session token information you can receive this token with the await client.getSessionTokenBrowser () function
   */
  browserSessionToken?: tokenSession;
  /**
   * A callback will be received, informing user about browser and page instance
   */
  browserInstance?: BrowserInstance;
}

/**
 * Start the bot
 * @returns Whatsapp page, with this parameter you will be able to access the bot functions
 */
export async function create(createOption: CreateOptions): Promise<Whatsapp>;
/**
 * Start the bot
 * You must pass a string type parameter, this parameter will be the name of the client's session. If the parameter is not passed, the section name will be "session".
 * @returns Whatsapp page, with this parameter you will be able to access the bot functions
 */
export async function create(
  sessionName: string,
  catchQR?: CatchQR,
  statusFind?: StatusFind,
  options?: CreateConfig,
  browserSessionToken?: tokenSession,
  browserInstance?: BrowserInstance
): Promise<Whatsapp>;

export async function create(
  sessionOrOption: string | CreateOptions,
  catchQR?: CatchQR,
  statusFind?: StatusFind,
  options?: CreateConfig,
  browserSessionToken?: tokenSession,
  browserInstance?: BrowserInstance
): Promise<Whatsapp> {
  let session = 'session';

  if (
    typeof sessionOrOption === 'string' &&
    sessionOrOption.replace(/\s/g, '').length
  ) {
    session = sessionOrOption.replace(/\s/g, '');
  } else if (typeof sessionOrOption === 'object') {
    session = sessionOrOption.session;
    catchQR = sessionOrOption.catchQR || catchQR;
    statusFind = sessionOrOption.statusFind || statusFind;
    browserSessionToken =
      sessionOrOption.browserSessionToken || browserSessionToken;
    browserInstance = sessionOrOption.browserInstance || browserInstance;
    options = sessionOrOption;
  }
  let browserToken: any;
  if (options?.multidevice != false) {
    const dirPath = `./${defaultOptions.folderNameToken}/${session}`;

    let existFile = fs.existsSync(dirPath + '.data.json');

    if (existFile) {
      fs.unlinkSync(dirPath + '.data.json');
    }

    defaultOptions.puppeteerOptions = {
      userDataDir: dirPath
    };
  }

  const mergedOptions = { ...defaultOptions, ...options };

  const logger = mergedOptions.logger;

  if (!mergedOptions.disableWelcome) {
    welcomeScreen();
  }
  // Initialize whatsapp
  if (mergedOptions.browserWS) {
    logger.info('Initializing browser...', { session });
  } else {
    logger.info('Initializing browser wss...', { session });
  }

  const browser = await initBrowser(session, mergedOptions);
  // Erro of connect wss
  if (typeof browser === 'string' && browser === 'connect') {
    logger.info('Error when try to connect ' + mergedOptions.browserWS, {
      session
    });
    statusFind && statusFind('serverWssNotConnected', this.session);
    throw `Error when try to connect ${mergedOptions.browserWS}`;
  }

  // Erro open browser
  if (typeof browser === 'string' && browser === 'launch') {
    logger.info('Error no open browser.... ', {
      session
    });
    statusFind && statusFind('noOpenBrowser', this.session);
    throw `Error no open browser....`;
  }

  if (mergedOptions.browserWS) {
    logger.info('Has been properly connected to the wss server', {
      session
    });
  } else {
    logger.info('Browser successfully opened', {
      session
    });
  }

  if (!mergedOptions.browserWS) {
    logger.info('checking headless...', {
      session
    });

    if (mergedOptions.headless) {
      logger.info('headless option is active, browser hidden', {
        session
      });
    } else {
      logger.info('headless option is disabled, browser visible', {
        session
      });
    }
  }

  if (typeof browser === 'object') {
    if (!mergedOptions.browserWS && browser['_process']) {
      browser['_process'].once('close', () => {
        browser['isClose'] = true;
      });
    }

    checkingCloses(browser, mergedOptions, (result) => {
      statusFind && statusFind(result, session);
    }).catch(() => {
      throw 'The client has been closed';
    });

    if (SessionTokenCkeck(browserSessionToken)) {
      browserToken = browserSessionToken;
    }
    logger.info('Checking page...', {
      session
    });

    // Initialize whatsapp
    const page: false | Page = await initWhatsapp(
      session,
      mergedOptions,
      browser,
      browserToken
    );

    if (browserInstance) {
      browserInstance(browser, page);
    }

    if (page === false) {
      logger.info('Error accessing the page: "https://web.whatsapp.com"', {
        session
      });
      throw 'Error when trying to access the page: "https://web.whatsapp.com"';
    }

    logger.info(`${chalk.green('Page successfully accessed')}`, {
      session
    });

    const client = new Whatsapp(page, session, mergedOptions);

    client.onStreamChange(async (stateStream) => {
      if (stateStream === SocketStream.CONNECTED) {
        statusFind && statusFind('chatsAvailable', session);
      }
      if (stateStream === SocketStream.DISCONNECTED) {
        await page.waitForFunction(
          () => {
            if (
              document.querySelector('canvas') &&
              document.querySelectorAll('#startup').length == 0
            ) {
              return true;
            }
          },
          {
            timeout: 0,
            polling: 100
          }
        );
        if (checkFileJson(mergedOptions, session)) {
          if (statusFind) {
            statusFind('desconnectedMobile', session);
          }
          deleteFiles(mergedOptions, session, logger);
        }
      }
    });

    client.onStateChange(async (state) => {
      if (state === SocketState.PAIRING) {
        await page.waitForFunction(
          () => {
            if (document.querySelectorAll('#startup').length) {
              return true;
            }
          },
          {
            timeout: 0,
            polling: 100
          }
        );
        if (statusFind) {
          statusFind('deviceNotConnected', session);
        }
      }
      if (mergedOptions.createPathFileToken) {
        if (state === SocketState.CONNECTED) {
          setTimeout(() => {
            saveToken(page, session, mergedOptions).catch((e) => {
              logger.info(e, {
                session
              });
            });
          }, 1000);
        }
      }
    });

    if (mergedOptions.waitForLogin) {
      const isLogged = await client.waitForLogin(catchQR, statusFind);
      if (!isLogged) {
        throw 'Not Logged';
      }

      let waitLoginPromise = null;
      client.onStateChange(async (state) => {
        if (
          state === SocketState.UNPAIRED ||
          state === SocketState.UNPAIRED_IDLE
        ) {
          if (!waitLoginPromise) {
            waitLoginPromise = client
              .waitForLogin(catchQR, statusFind)
              .catch(() => {})
              .finally(() => {
                waitLoginPromise = null;
              });
          }
          await waitLoginPromise;
        }
      });
    }

    if (mergedOptions.debug) {
      const debugURL = `http://localhost:${readFileSync(
        `./${session}/DevToolsActivePort`
      ).slice(0, -54)}`;
      console.log(`\nDebug: \x1b[34m${debugURL}\x1b[0m`);
    }
    await page.waitForSelector('#app .two', { visible: true }).catch(() => {});
    await page.waitForFunction(
      () => {
        if (
          window.Store &&
          window.Store.WidFactory &&
          window.Store.WidFactory.createWid
        ) {
          return true;
        }
      },
      {
        timeout: 0,
        polling: 100
      }
    );

    return client;
  }
}
