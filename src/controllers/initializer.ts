/*
NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
mMMMMMMMMMNNNmmNNNMMNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
mmNMMNMMMMNNNNNmmmddhdddNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
mddNMMNy:/odNmmddmmNNmdhhddmNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NmmdNMNd:--+dNmmddhhddmmhsyhhmdmmNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NmNmdNmy:.-oyNmmmhmdhho+sososyhhhddNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NmmNdh+-`.:oyNNdmmdmmdo-://oysssyhhhdmNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
Nmmmoyyyo+osdNmdmmddNNhs+/::/+osyssydyhdNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NNmhsymMMNmmmmdmdNNddNmsso+++////ossssyyhdmNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
mhhhmNNMNNNhssshhmmddmmssyooooso/::+oysshhhhmMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
mmdhdddNNdyoosyhdmddmmmsoooooyysyys/::/oyyhhhyMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
mdddhddmhsooshdmdmdhhyyyysso/ooo+syhhs/-/+shyhMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
dyyhdmd+ososhdmdmyyhhhhhhhyo++o/+///+ohhso++sdMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
dhdmNNdsossyhmdmsydhssssyhhs/++o/o+//:++yhhy+/hNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
mdmNNNNmhysshddyshdyyy/oss+s::/:://++///++++/::hmNNNNNNNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NNMNNNmmNNdymNNhshdshdyhdysh+sy+-:++osssosss++yNNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NmNNNmdNNmNmmmNmyyddyyhdhydyohys/-oo+osssysyyohNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
mmNNNhdNmmNNmNMMNhyyhhhdhyyhmmyh+-/s+sysssyyhyydNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
mNMMMhdNdmMNMMMMMNNmdhdddmhdmmNho/-osoyyo++oyddhhNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NMMMNmhNdNMNMNMMNmNNNmmmdyoohmhoyo::hsooo++oooydhymMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMNNNhmNNMmmNMNNmmmmdmmdyhhoyddddoo++yoyysooossyhsmMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMNNNmmNNNmdNdNmmddhhhdNNhsmNssdooo/dso++osyyysoymMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMNNNNmNNNNNmddmmNhshNmmmNmNMdhNsh/ohho++/:++MMNNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MNNNMMNNNNmmmhhhhdyosdNmdmMMhoNmhdmys+ooo++/+MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
mmNNNMMNNNNmddmdoodmMMNmmNNhssdmNMMMNdNd/osomMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NmNdhMNmNNMNmdNddohmMMNNNmdmdddNMMMMMMMMmMNNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NmNhmMmmmmNNmdNyoNMNmNmdhyyyhdhoyNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NmdmMmmddddNmmdys+hmMMMmmhysssyy++dMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NmdNMMdmdddmmNNyshmNNNNNNNdhhs+yy//dMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NmNMMMdmdddmmMNysdmNNMMMNhhNdhs+y+/:mMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
mmNMMNhmmddNNNMdyydmMMMNdyshNhyoss+:/MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NmNMMddmmmmNMNMNdsymNNmdhhdNMNdhsss+:yMMMMMMMMMMMMMMMMNNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMdhmmmmmNMNNMmshNMMMmmMMMMMmNdyo+//NMMMMMMMMMMMMMMMhNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMmhmmmmmmNMMNNMyshdhhhyhNMMMMMMdhso+sMMMMMMMMMMMMMMMhmMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMmdmmmmmmmNMMMmNm+ys++oyyNMMMMMMNmmyyoyNMMMMMMMMMMMMMddMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NmmmmmmmmmmmNMNNmNNyyo+/oohNMMMMMMMMdhhsshmMMMMMMMMMMMyNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
mmNNNNNNmmmmNMMNmmddNmmdhhdmMMMMMMMMMNddhssshmmNNNmmdhdMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NNNNNNNNNNNNNNNNmNNNNMMMMMNomMMMMMMMMMNNmdhhyyyyyyyhdmMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
Nd+oNMMMMMMMmodo++++++++++m..yNMMMMMNo+mNMMmhssshdNMMNhNMMMMMMMMMMMddMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MN+ /NMMMMMm: d` -ssssss+`d. `+mMMMMN. dNm+:+syso//hNN--yNMMMMMMMd+`yMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMN+ /NMMMm: oM` +NMMMMMNdN. /`.yNMMN. dh.omMMMMMNy.oM- `:hNMMMm+.  yMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMN/ /NMm: oNy` :sssmMMMMN. dh-`/mMN. d-/NMMMMMMMMy`m- y/`/dmo..o: yMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMN/ /m: +NNy. /yyyNMMMMN. dNNo`.yN- d.oNMMMMMMMMd d- mNh-`.`+mN/ yMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMN/ . +NMMN- oNMMMMMNdN. dMMMd:`/. ds.dNMMMMMMm::M- dMMNy/dMMN/ yMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMN/ +NMMMN- /yyyyyys d. dMMMMNo`  dNy-+ymmmho-+NN- dMMMMMMMMN/ yMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMNyNMMMMN+::::::::::m+/mMMMMMMd: dMMNho///+ymMMN+/mMMMMMMMMNs/hMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMNMMMMMMMMMMMMMMMMMMMMMMMMMMMMNsmMMMMMMMMMMMMMMNNNNMMNNNMMNNNNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNMMMMMMMMMMMMMMNMMNMNMMMNMMNNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNMMNMNMMMNMMNNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNNNNMMNNNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
*/
import { readFileSync, writeFileSync, mkdir, unlinkSync, existsSync } from 'fs';
import latestVersion from 'latest-version';
import { Whatsapp } from '../api/whatsapp';
import { CreateConfig, defaultOptions } from '../config/create-config';
import { upToDate } from '../utils/semver';
import {
  isAuthenticated,
  isInsideChat,
  asciiQr,
  retrieveQR,
  SessionTokenCkeck,
} from './auth';
import { initWhatsapp, injectApi, initBrowser } from './browser';
import chalk = require('chalk');
import boxen = require('boxen');
import * as Spinnies from 'spinnies';
import path = require('path');
import Counter = require('../lib/counter/Counter.js');
const { version } = require('../../package.json');
import {
  scrapeImgReload,
  scrapeImg,
  scrapeLogin,
  scrapeDesconnected,
  scrapeDeleteToken,
  deleteFiles,
} from '../api/helpers';

// Global
let updatesChecked = false;

/**
 * Start the bot
 * @param session, You must pass a string type parameter, this parameter will be the name of the client's session. If the parameter is not passed, the section name will be "session".
 * @param catchQR, A callback will be received, informing the status of the qrcode
 * @param statusFind, A callback will be received, informing the customer's status
 * @param options, Pass an object with the bot settings
 * @param browserSessionToken, Pass the session token information you can receive this token with the await client.getSessionTokenBrowser () function
 * @returns Whatsapp page, with this parameter you will be able to access the bot functions
 */

export async function create(
  session = 'session',
  catchQR?: (qrCode: string, asciiQR: string, attempt: number) => void,
  statusFind?: (statusGet: string, session: string) => void,
  options?: CreateConfig,
  browserSessionToken?: object
): Promise<Whatsapp> {
  var _fail: any,
    browser_check: any,
    closeBrowser: any,
    attempt = 0,
    browserToken: any,
    Session: string,
    clientCheck: any,
    Session = session,
    DelFileCheck = false;

  const spinnies = new Spinnies({
    disableSpins: options ? options.disableSpins : false,
  });

  const mergedOptions = { ...defaultOptions, ...options };

  if (!mergedOptions.disableWelcome) {
    console.log(`
     
    ▐█  ██  █░▐█▀▀▀░▐█     ▄█▀▀█▄ ▄█▀▀█▄ ▐██   ██▌ ▓█▀▀▀░
     █▌▐██▄▓█ ▐█▄▄▄ ▐█    ▐█      █▒  ▐█▄▐█▀▌ ▐▌█▌ ▓█▄▄▄
     ▐██ ▐██░ ▐█    ▐█    ▐█▄  ▄▀ █▌  ▐█ ▐█ █▓█ █▌ ██
      ▀▀  ▀▀  ▀▀▀▀▀░▐▀▀▀▀▀  ▀▀▀▀   ▀▀▀▀  ▐▀  ▀  ▀▀ ▀▀▀▀▀
                                   ▄
      ▄▄░          ▄ ▄▄▄▄▄▄▄▄▄▄▄▄▄ ██         ▄▄       ▄▄▄▄      ░
      ░██▄        ██ ███▀▀▀▀▀▀▀▀█▌ ███▌       ██▄  ▄▄█▀▀▀▀▀▀█▄   ▓█▄           ▄█░
       ░██▄     ░██▀ ███           ██▀██▄     ██▄ ▄█░        ▀█▄ ▓███▄      ░████░
         ██▌   ▄██░ ▄███▄▄▄▄       ██  ▓██▄   ██▄▐█           ▐█ ▓█▌▀██▄  ▄███░██░
          ██▌ ▄██░  ▀███▀▀▀▀       ██   ▐██▌  ██▄▐█           ▐█░▓█▌  ▀█████░  ██░
           ▓████     ███           ██     ▀██▄██▄ █▌          ██ ▓█▌    ▀█░    ██░
            ▀██      ███        █▌ ██       ▀███▄  ▀█▄     ▄▄█▀  ▓█▌           ██░
             ▀       ▀███████████▌ ██        ░██▄    ▀▀███▀▀░    ▀█▌           ▓█░
                                              ▀░                                   \n`);
  }
  // Check for updates if needed
  if (!updatesChecked && mergedOptions.updatesLog) {
    spinnies.add('venom-version-spinner', {
      text: 'Checking for updates',
    });
    await checkVenomVersion(spinnies);
    updatesChecked = true;
  }

  // Initialize whatsapp
  spinnies.add(`${Session}-auth`, {
    text: 'Waiting...',
  });

  var browser = await initBrowser(Session, mergedOptions);

  if (browser === 'connect') {
    spinnies.fail(`${Session}-auth`, {
      text: `Error when try to connect ${mergedOptions.browserWS}`,
    });
    browser = null;
    throw `Error when try to connect ${mergedOptions.browserWS}`;
  }

  if (browser === 'launch') {
    spinnies.fail(`${Session}-auth`, {
      text: `Error no open browser`,
    });
    browser = null;
    throw `Error no open browser`;
  }

  if (browser !== null) {
    spinnies.add(`browser`, {
      text: 'check headless',
    });

    if (mergedOptions.headless) {
      spinnies.succeed(`browser`, {
        text: 'headless option is active, browser hidden',
      });
    } else {
      spinnies.succeed(`browser`, {
        text: 'headless option is disabled, browser visible',
      });
    }

    if (!mergedOptions.browserWS) {
      browser['_process'].once('close', () => {
        browser['isClose'] = true;
      });
    }

    ///disconnect || close
    _fail = setInterval(() => {
      if (mergedOptions.browserWS) {
        if (browser.isConnected() === false) {
          spinnies.add(`${Session}-auths`, {
            text: '....',
          });

          spinnies.fail(`${Session}-auths`, {
            text: `The server is closed ${Session}`,
          });

          if (statusFind) {
            statusFind('serverClose', Session);
          }
          browser.close();
          clearTimeout(closeBrowser);
          clearInterval(browser_check);
          clearInterval(_fail);
        }
      }

      if (browser['isClose'] != undefined && !mergedOptions.browserWS) {
        spinnies.add(`${Session}-auths`, {
          text: '....',
        });
        spinnies.fail(`${Session}-auths`, {
          text: 'The browser is closed',
        });
        if (statusFind) {
          statusFind('browserClose', Session);
        }
        clearTimeout(closeBrowser);
        clearInterval(clientCheck);
        clearInterval(_fail);
      }
    }, 1000);

    if (SessionTokenCkeck(browserSessionToken)) {
      browserToken = browserSessionToken;
    }

    var waPage = await initWhatsapp(
      Session,
      mergedOptions,
      browser,
      browserToken
    );

    if (waPage) {
      spinnies.update(`${Session}-auth`, { text: 'Authenticating...' });
      let authenticated = null;
      clientCheck = setInterval(async () => {
        ////check delete file
        var DeleteToken = await scrapeDeleteToken(waPage).catch(() => {});
        if (!DelFileCheck && DeleteToken === true) {
          deleteFiles(mergedOptions, Session, spinnies);
          if (statusFind) {
            statusFind('deleteToken', Session);
          }
          DelFileCheck = true;
        }
        ///client disconnect mobile
        var clientInput = await scrapeLogin(waPage).catch(() => {}),
          clientExit = await scrapeDesconnected(waPage).catch(() => {});
        if (clientInput === true || clientExit === true) {
          spinnies.add(`${Session}-authS`, { text: '...' });
          spinnies.fail(`${Session}-authS`, {
            text: 'client has desconnected in to mobile',
          });
          if (statusFind) {
            statusFind('desconnectedMobile', Session);
          }
          deleteFiles(mergedOptions, Session, spinnies);
          browser.close();
          browser.disconnect();
          clearInterval(_fail);
          clearInterval(browser_check);
          clearTimeout(closeBrowser);
          clearInterval(clientCheck);
        }
      }, 1000);

      //session authenticated
      await isAuthenticated(waPage)
        .then((e) => {
          authenticated = e;
        })
        .catch(() => {});

      if (authenticated != null) {
        // If not authenticated, show QR and wait for scan
        if (authenticated) {
          // Wait til inside chat
          if (statusFind) {
            statusFind('isLogged', Session);
          }

          await isInsideChat(waPage).toPromise();
          spinnies.succeed(`${Session}-auth`, { text: 'Authenticated' });
        } else {
          if (statusFind) {
            statusFind('notLogged', Session);
          }
          spinnies.add(`autoclose`, { text: 'check autoClose' });

          if (mergedOptions.autoClose > 0) {
            spinnies.succeed(`autoclose`, {
              text: 'the autoClose function is on',
            });
            ////on autoclose
            closeBrowser = setTimeout(() => {
              browser.disconnect();
              browser.close();
              if (statusFind) {
                statusFind('autocloseCalled', Session);
              }
              spinnies.add(`${Session}-auths`, {
                text: `....`,
              });
              spinnies.fail(`${Session}-auths`, {
                text: `Session Autoclose Called`,
              });

              clearInterval(_fail);
              clearInterval(browser_check);
              clearTimeout(closeBrowser);
              clearInterval(clientCheck);
            }, mergedOptions.autoClose);
          } else {
            spinnies.succeed(`autoclose`, {
              text: 'the autoClose function is off ',
            });
          }

          let tipo_qr = 0,
            result = undefined,
            url = null;

          ///scraper qrcode
          browser_check = setInterval(async () => {
            ///close client browser
            if (
              browser['isClose'] != undefined ||
              browser.isConnected() === false
            ) {
              if (statusFind) {
                statusFind('qrReadFail', Session);
              }
              clearTimeout(closeBrowser);
              clearInterval(_fail);
              clearInterval(browser_check);
            } else {
              switch (tipo_qr) {
                case 0:
                  result = await scrapeImg(waPage).catch(() => {});
                  if (result != undefined) {
                    var retri = await retrieveQR(waPage).catch(() => {});
                    if (retri) {
                      var { data, asciiQR } = retri;
                      if (catchQR) {
                        catchQR(data, asciiQR, attempt++);
                      }
                      await asciiQr(result['url'])
                        .then((qr) => {
                          if (mergedOptions.logQR) {
                            spinnies.update(`${Session}-auth`, {
                              text: 'Scan QR for Session: ' + Session,
                            });
                            console.log(qr);
                          }
                          tipo_qr++;
                        })
                        .catch(() => {});
                    }
                  }
                  break;
                case 1:
                  result = await scrapeImgReload(waPage, url).catch(() => {});
                  if (typeof result === 'object') {
                    url = result.url;
                  }
                  if (typeof result === 'object' && result.status === true) {
                    let re = await scrapeImg(waPage).catch(() => {});
                    if (re != undefined) {
                      var retri = await retrieveQR(waPage).catch(() => {});
                      if (retri) {
                        var { data, asciiQR } = retri;
                        if (catchQR) {
                          catchQR(data, asciiQR, attempt++);
                        }
                        await asciiQr(re['url'])
                          .then((qr) => {
                            if (mergedOptions.logQR) {
                              spinnies.update(`${Session}-auth`, {
                                text: 'Scan QR for Session: ' + Session,
                              });
                              console.log(qr);
                            }
                          })
                          .catch(() => {});
                      }
                    }
                  }
                  break;
              }
            }
          }, 1000);

          var IsLog = await isInsideChat(waPage).toPromise();
          if (IsLog == false) {
            spinnies.fail(`${Session}-auth`, {
              text: 'Not Login',
            });
            throw 'Error in login';
          }
          if (statusFind) {
            statusFind('qrReadSuccess', Session);
          }
          spinnies.succeed(`${Session}-auth`, {
            text: 'Compilation Mutation',
          });
        }

        clearInterval(browser_check);
        clearTimeout(closeBrowser);
        spinnies.add(`${Session}-inject`, { text: 'Injecting Sibionte...' });
        waPage = await injectApi(waPage);
        spinnies.succeed(`${Session}-inject`, {
          text: 'Starting With Success!',
        });

        // Saving Token
        spinnies.add(`${Session}-inject`, { text: 'Saving Token...' });

        if (true || (browserToken && !mergedOptions.createPathFileToken)) {
          const localStorage = JSON.parse(
            await waPage.evaluate(() => {
              return JSON.stringify(window.localStorage);
            })
          );

          let {
            WABrowserId,
            WASecretBundle,
            WAToken1,
            WAToken2,
          } = localStorage;

          try {
            setTimeout(() => {
              mkdir(
                path.join(
                  path.resolve(
                    process.cwd() + mergedOptions.mkdirFolderToken,
                    mergedOptions.folderNameToken
                  )
                ),
                { recursive: true },
                (err) => {
                  if (err) {
                    spinnies.fail(`${Session}-inject`, {
                      text: 'Failed to create folder tokens...',
                    });
                  }
                }
              );
            }, 200);

            setTimeout(() => {
              writeFileSync(
                path.join(
                  path.resolve(
                    process.cwd() + mergedOptions.mkdirFolderToken,
                    mergedOptions.folderNameToken
                  ),
                  `${Session}.data.json`
                ),
                JSON.stringify({
                  WABrowserId,
                  WASecretBundle,
                  WAToken1,
                  WAToken2,
                })
              );
              spinnies.succeed(`${Session}-inject`, {
                text: 'Token saved successfully...',
              });
            }, 500);
          } catch (error) {
            spinnies.fail(`${Session}-inject`, {
              text: 'Failed to save token...',
            });
          }
        }

        if (mergedOptions.debug) {
          const debugURL = `http://localhost:${readFileSync(
            `./${Session}/DevToolsActivePort`
          ).slice(0, -54)}`;
          console.log(`\nDebug: \x1b[34m${debugURL}\x1b[0m`);
        }

        return new Whatsapp(waPage);
      }
    }
  }
}

/**
 * Checs for a new versoin of venom and logs
 */
async function checkVenomVersion(spinnies: Spinnies) {
  spinnies.update('venom-version-spinner', { text: 'Checking for updates...' });
  await latestVersion('venom-bot').then((latest) => {
    if (upToDate(version, latest)) {
      spinnies.succeed('venom-version-spinner', { text: "You're up to date" });
    } else {
      spinnies.succeed('venom-version-spinner', {
        text: 'There is a new version available',
      });
      logUpdateAvailable(version, latest);
    }
  });
}

/**
 * Logs a boxen of instructions to update
 * @param current
 * @param latest
 */
function logUpdateAvailable(current: string, latest: string) {
  // prettier-ignore
  const newVersionLog =
    `There is a new version of ${chalk.bold(`Venom`)} ${chalk.gray(current)} ➜  ${chalk.bold.green(latest)}\n` +
    `Update your package by running:\n\n` +
    `${chalk.bold('\>')} ${chalk.blueBright('npm update venom-bot')}`;

  console.log(boxen(newVersionLog, { padding: 1 }));
  console.log(
    `For more info visit: ${chalk.underline(
      'https://github.com/orkestral/venom/blob/master/Update.md'
    )}\n`
  );
}
