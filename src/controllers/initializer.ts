/*
NNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNN
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
mMMMMMMMMMNNNmmNNNMMNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
mmNMMNMMMMNNNNNmmmddhdddNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
mddNMMNy:/odNmmddmmNNmdhhddmNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NmmdNMNd:--+dNmmddhhddmmhsyhhmdmmNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NmNmdNmy:.-oyNmmmhmdhho+sososyhhhddNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NmmNdh+-`.:oyNNdmmdmmdo-://oysssyhhhdmNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
Nmmmoyyyo+osdNmdmmddNNhs+/::/+osyssydyhdNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NNmhsymMMNmmmmdmdNNddNmsso+++////ossssyyhdmNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
mhhhmNNMNNNhssshhmmddmmssyooooso/::+oysshhhhmMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
mmdhdddNNdyoosyhdmddmmmsoooooyysyys/::/oyyhhhyMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
mdddhddmhsooshdmdmdhhyyyysso/ooo+syhhs/-/+shyhMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
dyyhdmd+ososhdmdmyyhhhhhhhyo++o/+///+ohhso++sdMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
dhdmNNdsossyhmdmsydhssssyhhs/++o/o+//:++yhhy+/hNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
mdmNNNNmhysshddyshdyyy/oss+s::/:://++///++++/::hmNNNNNNNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NNMNNNmmNNdymNNhshdshdyhdysh+sy+-:++osssosss++yNNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NmNNNmdNNmNmmmNmyyddyyhdhydyohys/-oo+osssysyyohNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
mmNNNhdNmmNNmNMMNhyyhhhdhyyhmmyh+-/s+sysssyyhyydNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
mNMMMhdNdmMNMMMMMNNmdhdddmhdmmNho/-osoyyo++oyddhhNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NMMMNmhNdNMNMNMMNmNNNmmmdyoohmhoyo::hsooo++oooydhymMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMNNNhmNNMmmNMNNmmmmdmmdyhhoyddddoo++yoyysooossyhsmMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMNNNmmNNNmdNdNmmddhhhdNNhsmNssdooo/dso++osyyysoymMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMNNNNmNNNNNmddmmNhshNmmmNmNMdhNsh/ohho++/:++MMNNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MNNNMMNNNNmmmhhhhdyosdNmdmMMhoNmhdmys+ooo++/+MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
mmNNNMMNNNNmddmdoodmMMNmmNNhssdmNMMMNdNd/osomMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NmNdhMNmNNMNmdNddohmMMNNNmdmdddNMMMMMMMMmMNNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NmNhmMmmmmNNmdNyoNMNmNmdhyyyhdhoyNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NmdmMmmddddNmmdys+hmMMMmmhysssyy++dMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NmdNMMdmdddmmNNyshmNNNNNNNdhhs+yy//dMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NmNMMMdmdddmmMNysdmNNMMMNhhNdhs+y+/:mMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
mmNMMNhmmddNNNMdyydmMMMNdyshNhyoss+:/MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NmNMMddmmmmNMNMNdsymNNmdhhdNMNdhsss+:yMMMMMMMMMMMMMMMMNNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMdhmmmmmNMNNMmshNMMMmmMMMMMmNdyo+//NMMMMMMMMMMMMMMMhNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMmhmmmmmmNMMNNMyshdhhhyhNMMMMMMdhso+sMMMMMMMMMMMMMMMhmMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMmdmmmmmmmNMMMmNm+ys++oyyNMMMMMMNmmyyoyNMMMMMMMMMMMMMddMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NmmmmmmmmmmmNMNNmNNyyo+/oohNMMMMMMMMdhhsshmMMMMMMMMMMMyNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
mmNNNNNNmmmmNMMNmmddNmmdhhdmMMMMMMMMMNddhssshmmNNNmmdhdMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
NNNNNNNNNNNNNNNNmNNNNMMMMMNomMMMMMMMMMNNmdhhyyyyyyyhdmMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
Nd+oNMMMMMMMmodo++++++++++m..yNMMMMMNo+mNMMmhssshdNMMNhNMMMMMMMMMMMddMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MN+ /NMMMMMm: d` -ssssss+`d. `+mMMMMN. dNm+:+syso//hNN--yNMMMMMMMd+`yMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMN+ /NMMMm: oM` +NMMMMMNdN. /`.yNMMN. dh.omMMMMMNy.oM- `:hNMMMm+.  yMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMN/ /NMm: oNy` :sssmMMMMN. dh-`/mMN. d-/NMMMMMMMMy`m- y/`/dmo..o: yMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMN/ /m: +NNy. /yyyNMMMMN. dNNo`.yN- d.oNMMMMMMMMd d- mNh-`.`+mN/ yMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMN/ . +NMMN- oNMMMMMNdN. dMMMd:`/. ds.dNMMMMMMm::M- dMMNy/dMMN/ yMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMN/ +NMMMN- /yyyyyys d. dMMMMNo`  dNy-+ymmmho-+NN- dMMMMMMMMN/ yMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMNyNMMMMN+::::::::::m+/mMMMMMMd: dMMNho///+ymMMN+/mMMMMMMMMNs/hMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMNMMMMMMMMMMMMMMMMMMMMMMMMMMMMNsmMMMMMMMMMMMMMMNNNNMMNNNMMNNNNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNMMMMMMMMMMMMMMNMMNMNMMMNMMNNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNMMNMNMMMNMMNNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNNNNMMNNNMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
MMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMM
*/

import * as chalk from 'chalk';

import { readFileSync } from 'fs';

import { Browser, Page } from 'puppeteer';

import { deleteFiles, checkingCloses } from '../api/helpers';
import { Whatsapp } from '../api/whatsapp';
import { CreateConfig, defaultOptions } from '../config/create-config';
import { tokenSession } from '../config/tokenSession.config';
import { checkFileJson } from '../api/helpers/check-token-file';
import { SocketState, SocketStream } from '../api/model/enum';
import { SessionTokenCkeck, saveToken, isBeta } from './auth';
import {
  initWhatsapp,
  initBrowser,
  injectApi,
  getWhatsappPage
} from './browser';
import { welcomeScreen } from './welcome';
const path = require('path');
/**
 * A callback will be received, informing the status of the qrcode
 */
export type CatchQR = (
  qrCode: string,
  asciiQR: string,
  attempt: number,
  urlCode?: string
) => void;

/**
 * A callback will be received, informing the customer's status
 */
export type StatusFind = (statusGet: string, session: string) => void;

/**
 * A callback will be received, informing user about browser and page instance
 */
export type BrowserInstance = (
  browser: string | Browser,
  waPage: false | Page
) => void;

export interface CreateOptions extends CreateConfig {
  /**
   * You must pass a string type parameter, this parameter will be the name of the client's session. If the parameter is not passed, the section name will be "session".
   */
  session: string;
  /**
   * A callback will be received, informing the status of the qrcode
   */
  catchQR?: CatchQR;
  /**
   * A callback will be received, informing the customer's status
   */
  statusFind?: StatusFind;
  /**
   * Pass the session token information you can receive this token with the await client.getSessionTokenBrowser () function
   */
  browserSessionToken?: tokenSession;
  /**
   * A callback will be received, informing user about browser and page instance
   */
  browserInstance?: BrowserInstance;
}

/**
 * Start the bot
 * @returns Whatsapp page, with this parameter you will be able to access the bot functions
 */
export async function create(createOption: CreateOptions): Promise<Whatsapp>;
/**
 * Start the bot
 * You must pass a string type parameter, this parameter will be the name of the client's session. If the parameter is not passed, the section name will be "session".
 * @returns Whatsapp page, with this parameter you will be able to access the bot functions
 */
export async function create(
  sessionName: string,
  catchQR?: CatchQR,
  statusFind?: StatusFind,
  options?: CreateConfig,
  browserSessionToken?: tokenSession,
  browserInstance?: BrowserInstance
): Promise<Whatsapp>;

export async function create(
  sessionOrOption: string | CreateOptions,
  catchQR?: CatchQR,
  statusFind?: StatusFind,
  options?: CreateConfig,
  browserSessionToken?: tokenSession,
  browserInstance?: BrowserInstance
): Promise<Whatsapp> {
  let session = 'session';

  if (
    typeof sessionOrOption === 'string' &&
    sessionOrOption.replace(/\s/g, '').length
  ) {
    session = sessionOrOption.replace(/\s/g, '');
  } else if (typeof sessionOrOption === 'object') {
    session = sessionOrOption.session || session;
    catchQR = sessionOrOption.catchQR || catchQR;
    statusFind = sessionOrOption.statusFind || statusFind;
    browserSessionToken =
      sessionOrOption.browserSessionToken || browserSessionToken;
    browserInstance = sessionOrOption.browserInstance || browserInstance;
    options = sessionOrOption;
  }
  let browserToken: any;

  const mergedOptions = { ...defaultOptions, ...options };

  const logger = mergedOptions.logger;

  if (!mergedOptions.disableWelcome) {
    welcomeScreen();
  }

  logger.info(`${chalk.underline('https://orkestral.io - official site!')}\n`);

  statusFind && statusFind('initBrowser', session);

  // Initialize whatsapp
  if (mergedOptions.browserWS) {
    logger.info(`Waiting... checking the wss server...`, { session });
  } else {
    logger.info('Waiting... checking the browser...', { session });
  }

  const browser = await initBrowser(session, mergedOptions, logger);
  // Erro of connect wss
  if (typeof browser === 'string' && browser === 'connect') {
    logger.info('Error when try to connect ' + mergedOptions.browserWS, {
      session
    });
    statusFind && statusFind('serverWssNotConnected', session);
    throw `Error when try to connect ${mergedOptions.browserWS}`;
  }

  // Erro open browser
  if (typeof browser === 'string' && browser === 'launch') {
    logger.info('Error no open browser.... ', {
      session
    });
    statusFind && statusFind('noOpenBrowser', session);
    throw `Error no open browser....`;
  }

  if (mergedOptions.browserWS) {
    logger.info('Has been properly connected to the wss server', {
      session
    });
    statusFind && statusFind('connectBrowserWs', session);
  } else {
    statusFind && statusFind('openBrowser', session);
    logger.info('Browser successfully opened', {
      session
    });
  }

  if (!mergedOptions.browserWS) {
    logger.info('checking headless...', {
      session
    });

    if (mergedOptions.headless) {
      logger.info('headless option is active, browser hidden', {
        session
      });
    } else {
      logger.info('headless option is disabled, browser visible', {
        session
      });
    }
  }

  if (typeof browser === 'object') {
    if (!mergedOptions.browserWS && browser['_process']) {
      browser['_process'].once('close', () => {
        browser['isClose'] = true;
      });
    }

    checkingCloses(browser, mergedOptions, (result) => {
      statusFind && statusFind(result, session);
    }).catch(() => {
      throw 'The client has been closed';
    });

    if (SessionTokenCkeck(browserSessionToken)) {
      browserToken = browserSessionToken;
    }

    logger.info('Checking page...', {
      session
    });

    statusFind && statusFind('initWhatsapp', session);

    const newPage: Page = await getWhatsappPage(browser);
    const client = new Whatsapp(newPage, session, mergedOptions);
    const page: false | Page = await initWhatsapp(
      session,
      mergedOptions,
      browser,
      browserToken
    );

    if (browserInstance) {
      browserInstance(browser, page);
    }

    if (page === false) {
      logger.info('Error accessing the page: "https://web.whatsapp.com"', {
        session
      });

      statusFind && statusFind('erroPageWhatsapp', session);
      throw 'Error when trying to access the page: "https://web.whatsapp.com"';
    }

    statusFind && statusFind('successPageWhatsapp', session);
    logger.info(`${chalk.green('Page successfully accessed')}`, {
      session
    });

    client.onStreamChange(async (stateStream) => {
      if (stateStream === SocketStream.CONNECTED) {
        statusFind && statusFind('chatsAvailable', session);
      }
      if (stateStream === SocketStream.DISCONNECTED) {
        await page.waitForFunction(
          () => {
            if (
              document.querySelector('canvas') &&
              document.querySelectorAll('._2Nr6U').length == 0
            ) {
              return true;
            }
          },
          {
            timeout: 0,
            polling: 100
          }
        );
        if (checkFileJson(mergedOptions, session)) {
          if (statusFind) {
            statusFind('desconnectedMobile', session);
          }
          deleteFiles(mergedOptions, session, logger);
        }
      }
    });

    client.onStateChange(async (state) => {
      if (state === SocketState.PAIRING) {
        const device: Boolean = await page
          .evaluate(() => {
            if (
              document.querySelector('[tabindex="-1"]') &&
              window?.Store?.Stream?.mode == 'SYNCING' &&
              window?.Store?.Stream?.obscurity == 'SHOW'
            ) {
              return true;
            }
            return false;
          })
          .catch(() => undefined);
        if (device) {
          const ckeckVersion = await isBeta(page);
          if (ckeckVersion === false) {
            await page.evaluate(async () => {
              await window.Store.Login.triggerCriticalSyncLogout();
            });
          }
          if (statusFind) {
            statusFind('deviceNotConnected', session);
          }
        }
      }

      if (mergedOptions.createPathFileToken) {
        if (state === SocketState.CONNECTED) {
          setTimeout(() => {
            saveToken(page, session, mergedOptions).catch((e) => {
              logger.info(e, {
                session
              });
            });
          }, 1000);
        }
      }
    });

    page.on('dialog', async (dialog) => {
      await dialog.accept();
    });

    if (mergedOptions.waitForLogin) {
      if (mergedOptions.debug) {
        console.log(`\nDebug: Option waitForLogin it's true. waiting...`);
      }

      statusFind && statusFind('waitForLogin', session);

      const isLogged = await client.waitForLogin(catchQR, statusFind);

      if (!isLogged) {
        throw 'Not Logged';
      }

      let waitLoginPromise = null;
      client.onStateChange(async (state) => {
        if (
          state === SocketState.UNPAIRED ||
          state === SocketState.UNPAIRED_IDLE
        ) {
          if (!waitLoginPromise) {
            waitLoginPromise = client
              .waitForLogin(catchQR, statusFind)
              .catch(() => {})
              .finally(() => {
                waitLoginPromise = null;
              });
          }
          await waitLoginPromise;
        }
      });
    }

    if (mergedOptions.debug) {
      const debugURL = `http://localhost:${readFileSync(
        path.resolve(
          process.cwd() + mergedOptions.mkdirFolderToken,
          mergedOptions.folderNameToken,
          session,
          'DevToolsActivePort'
        )
      ).slice(0, -54)}`;
      console.log(`\nDebug: \x1b[34m${debugURL}\x1b[0m`);
    }

    if (mergedOptions.debug) {
      console.log(
        `\nDebug: Init WP app... waitForFunction "Store" ... this might take a while`
      );
    }

    statusFind && statusFind('waitChat', session);

    await page.waitForSelector('#app .two', { visible: true }).catch(() => {});

    if (mergedOptions.debug) {
      console.log(
        `\nDebug: Loading wp app... waitForFunction "Store" ... this might take a while also`
      );
    }

    await page
      .waitForFunction(
        () => {
          if (mergedOptions.debug) {
            console.log(`\nDebug: Loading wp app....`);
          }
          const StoreKey = Object.keys(window).find(
            (k) =>
              !!Object.getOwnPropertyDescriptor(window[k], 'WidFactory') &&
              !!Object.getOwnPropertyDescriptor(
                window[k].WidFactory,
                'createWid'
              )
          );
          if (StoreKey) {
            window.Store = window[StoreKey];
            return true;
          }
          return false;
        },
        {
          timeout: 0,
          polling: 100
        }
      )
      .catch(() => {});

    if (mergedOptions.debug) {
      console.log(`\nDebug: injecting Api ...`);
    }

    await injectApi(page);

    if (mergedOptions.debug) {
      console.log(`\nDebug: injecting Api done...`);
    }
    statusFind && statusFind('successChat', session);
    return client;
  }
}
